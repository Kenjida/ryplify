
import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import multer from 'multer';
import geoip from 'geoip-lite';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();

app.set('trust proxy', 1);



// Use the port assigned by the environment, or fall back to 3002

const port = process.env.PORT || 3002;



const dbPath = path.join(__dirname, 'public', 'db.json');

const uploadsDir = path.join(__dirname, 'public', 'uploads');

const JWT_SECRET = 'your-super-secret-key-that-should-be-in-env-vars'; // In a real app, use environment variables



// --- MIDDLEWARE ---



const whitelist = ['https://vibecoding.ryplify.eu', 'https://prolidi.ryplify.eu'];



const corsOptions = {



  origin: function (origin, callback) {



    // Allow requests with no origin (like mobile apps or curl requests)



    if (!origin) return callback(null, true);



    if (whitelist.indexOf(origin) !== -1) {



      callback(null, true);



    } else {



      callback(new Error('Not allowed by CORS'));



    }



  }



};



app.use(cors(corsOptions));



app.use(bodyParser.json());







// Serve static assets



app.use('/uploads', express.static(uploadsDir));





// --- DB HELPER FUNCTIONS ---





const readDB = () => {





  // If the database file doesn't exist, return a default structure.





  // The app will create the file on its first write.





  if (!fs.existsSync(dbPath)) {





    console.log('Database file not found. A new one will be created.');





    return { articles: [], formSubmissions: [], pageViews: [], user: null };





  }











  try {





    const dbRaw = fs.readFileSync(dbPath, 'utf-8');





    // Handle case where the file is empty





    if (dbRaw.trim() === '') {





      return { articles: [], formSubmissions: [], pageViews: [], user: null };





    }





    return JSON.parse(dbRaw);





  } catch (error) {





    console.error("Error reading or parsing database file:", error);





    // If the file is corrupt, return a default structure to allow the app to start





    // and potentially overwrite the corrupt file.





    return { articles: [], formSubmissions: [], pageViews: [], user: null };





  }





};











const writeDB = (data) => {











  try {











    fs.writeFileSync(dbPath, JSON.stringify(data, null, 2));











    return true; // Success











  } catch (error) {











    console.error("CRITICAL: Error writing to database file:", error);











    return false; // Failure











  }











};























// --- INITIALIZATION ---























const initializeUser = async () => {











  const db = readDB();











  if (!db.user) {











    console.log('No user found, creating default user...');











    const salt = await bcrypt.genSalt(10);











    const hashedPassword = await bcrypt.hash('Samurai10', salt);











    db.user = {











      username: 'Kenji',











      password: hashedPassword











    };











    if (!writeDB(db)) {











      console.error('Failed to write default user to DB during initialization.');











    }











    console.log('Default user created.');











  }











};























// Create uploads directory if it doesn't exist











if (!fs.existsSync(uploadsDir)) {











  fs.mkdirSync(uploadsDir, { recursive: true });











}























// --- AUTHENTICATION --- 























// Login Endpoint











app.post('/api/login', async (req, res) => {











  const { username, password } = req.body;











  const db = readDB();











  const user = db.user;























  if (!user || user.username !== username) {











    return res.status(400).json({ message: 'Nesprávné jméno nebo heslo.' });











  }























  const isMatch = await bcrypt.compare(password, user.password);























  if (!isMatch) {











    return res.status(400).json({ message: 'Nesprávné jméno nebo heslo.' });











  }























  const token = jwt.sign({ username: user.username }, JWT_SECRET, { expiresIn: '8h' });











  res.json({ token });











});























// Token Verification Middleware











const verifyToken = (req, res, next) => {











    const authHeader = req.headers['authorization'];











    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN























    if (token == null) return res.sendStatus(401); // if there isn't any token























    jwt.verify(token, JWT_SECRET, (err, user) => {











        if (err) return res.sendStatus(403);











        req.user = user;











        next(); // pass the execution off to whatever request the client intended











    });











};























// Change Password Endpoint











app.post('/api/change-password', verifyToken, async (req, res) => {











    const { oldPassword, newPassword } = req.body;











    const db = readDB();











    const user = db.user;























    const isMatch = await bcrypt.compare(oldPassword, user.password);











    if (!isMatch) {











        return res.status(400).json({ message: 'Původní heslo není správné.' });











    }























    const salt = await bcrypt.genSalt(10);











    const hashedPassword = await bcrypt.hash(newPassword, salt);











    db.user.password = hashedPassword;











    











    if (writeDB(db)) {











        res.json({ message: 'Heslo bylo úspěšně změněno.' });











    } else {











        res.status(500).json({ message: 'Nepodařilo se uložit nové heslo.' });











    }











});























// --- PROJECTS API ---























app.get('/api/projects', (req, res) => {











    const db = readDB();











    res.json(db.projects || []);











});























app.post('/api/projects', (req, res) => {











    const db = readDB();











    const { name, isFree } = req.body;











    const newProject = {











        id: new Date().toISOString(),











        name,











        totalSeconds: 0,











        isActive: true,











        isFree: isFree,











        startTime: null,











        timeEntries: [],











    };











    db.projects = [...(db.projects || []), newProject];











    if (writeDB(db)) {











        res.status(201).json(newProject);











    } else {











        res.status(500).json({ message: 'Failed to save project.' });











    }











});























app.delete('/api/projects/:id', (req, res) => {











    const db = readDB();











    const { id } = req.params;











    const initialLength = db.projects ? db.projects.length : 0;











    db.projects = (db.projects || []).filter(p => p.id !== id);











    











    if (db.projects.length < initialLength) {











        if (writeDB(db)) {











            res.status(204).send();











        } else {











            res.status(500).json({ message: 'Failed to delete project.' });











        }











    } else {











        res.status(404).json({ message: 'Project not found.' });











    }











});























app.post('/api/projects/:id/toggle', (req, res) => {











    const db = readDB();











    const { id } = req.params;











    const project = (db.projects || []).find(p => p.id === id);























    if (!project) {











        return res.status(404).json({ message: 'Project not found.' });











    }























    const isRunning = project.startTime !== null;























    if (isRunning) {











        // Stop timer











        const now = Date.now();











        const startTime = project.startTime;











        const elapsedSeconds = (now - startTime) / 1000;











        const newTimeEntry = {











            start: startTime,











            end: now,











            note: req.body.note || '' 











        };











        project.startTime = null;











        project.totalSeconds += elapsedSeconds;











        project.timeEntries.push(newTimeEntry);











    } else {











        // Start timer











        project.startTime = Date.now();











    }























    db.projects = db.projects.map(p => p.id === id ? project : p);























    if (writeDB(db)) {











        res.json(project);











    } else {











        res.status(500).json({ message: 'Failed to toggle timer.' });











    }











});























app.put('/api/projects/:id', (req, res) => {











    const db = readDB();











    const { id } = req.params;











    const updatedProjectData = req.body;























    const projectIndex = (db.projects || []).findIndex(p => p.id === id);























    if (projectIndex === -1) {











        return res.status(404).json({ message: 'Project not found.' });











    }























    // Ensure timeEntries is always an array











    if (!updatedProjectData.timeEntries) {











        updatedProjectData.timeEntries = [];











    }











    











    // Recalculate totalSeconds from timeEntries to ensure consistency











    const totalSeconds = updatedProjectData.timeEntries.reduce((acc, entry) => {











        return acc + (entry.end - entry.start) / 1000;











    }, 0);























    const updatedProject = { 











        ...db.projects[projectIndex], 











        ...updatedProjectData,











        totalSeconds: totalSeconds











    };























    db.projects[projectIndex] = updatedProject;























    if (writeDB(db)) {











        res.json(updatedProject);











    } else {











        res.status(500).json({ message: 'Failed to update project.' });











    }











});



































// --- UTILITY FUNCTIONS ---











const slugify = (text) => {











  return text.toString().toLowerCase()











    .normalize('NFD')           // split an accented letter in the base letter and the acent











    .replace(/[\u0300-\u036f]/g, '') // remove all previously split accents











    .replace(/\s+/g, '-')        // Replace spaces with -











    .replace(/[^\w\-]+/g, '')    // Remove all non-word chars











    .replace(/\-\-+/g, '-')      // Replace multiple - with single -











    .replace(/^-+/, '')          // Trim - from start of text











    .replace(/-+$/, '');         // Trim - from end of text











};



































// --- FILE UPLOAD ---











const storage = multer.diskStorage({











  destination: (req, file, cb) => cb(null, uploadsDir),











  filename: (req, file, cb) => cb(null, Date.now() + '-' + file.originalname)











});











const upload = multer({ storage: storage });























app.post('/api/upload', verifyToken, upload.single('image'), (req, res) => {











  if (!req.file) {











    return res.status(400).send('No file uploaded.');











  }











  res.json({ imageUrl: `/uploads/${req.file.filename}` });











});























// --- ARTICLES API ---











app.get('/api/articles', (req, res) => {











  const db = readDB();











  res.json(db.articles);











});























app.get('/api/articles/:slug', (req, res) => {











  const db = readDB();











  // First, try to find by slug











  let article = db.articles.find(a => a.slug === req.params.slug);











  // If not found, try to find by ID (for backward compatibility)











  if (!article) {











    const articleId = parseInt(req.params.slug, 10);











    if (!isNaN(articleId)) {











      article = db.articles.find(a => a.id === articleId);











    }











  }











  











  if (article) res.json(article);











  else res.status(404).send('Article not found');











});























app.post('/api/articles', verifyToken, (req, res) => {











  const db = readDB();











  const { title, perex, content, imageUrl } = req.body;











  const slug = slugify(title);











  const newArticle = { id: Date.now(), title, perex, content, imageUrl, slug };











  db.articles.push(newArticle);











  











  if (writeDB(db)) {











    res.status(201).json(newArticle);











  } else {











    res.status(500).json({ message: 'Failed to save article.' });











  }











});























app.put('/api/articles/:id', verifyToken, (req, res) => {











  const db = readDB();











  const articleId = parseInt(req.params.id, 10);











  const articleIndex = db.articles.findIndex(a => a.id === articleId);











  if (articleIndex === -1) return res.status(404).send('Article not found');











  











  const { title } = req.body;











  const newSlug = title ? slugify(title) : db.articles[articleIndex].slug;























  const updatedArticle = { 











    ...db.articles[articleIndex], 











    ...req.body,











    slug: newSlug











  };











  db.articles[articleIndex] = updatedArticle;











  











  if (writeDB(db)) {











    res.json(updatedArticle);











  } else {











    res.status(500).json({ message: 'Failed to update article.' });











  }











});























app.delete('/api/articles/:id', verifyToken, (req, res) => {











  const db = readDB();











  const newArticles = db.articles.filter(a => a.id !== parseInt(req.params.id, 10));











  if (db.articles.length === newArticles.length) return res.status(404).send('Article not found');











  db.articles = newArticles;











  











  if (writeDB(db)) {











    res.status(204).send();











  } else {











    res.status(500).json({ message: 'Failed to delete article.' });











  }











});























// --- OTHER APIs (Contact, Analytics) ---











app.get('/api/contact', verifyToken, (req, res) => {











  const db = readDB();











  res.json(db.formSubmissions || []);











});























// POST a new form submission























app.post('/api/contact', (req, res) => {















































  console.log('--- Received /api/contact request ---');















































  console.log('Request Body:', req.body);































































































  const db = readDB();















































  if (!db.formSubmissions) db.formSubmissions = [];















































  const newSubmission = { id: Date.now(), submittedAt: new Date().toISOString(), ...req.body };















































  db.formSubmissions.push(newSubmission);















































  















































  if (writeDB(db)) {















































    console.log('Submission saved successfully.');















































    res.status(201).json(newSubmission);















































  } else {















































    console.log('ERROR: Failed to write submission to db.json.');















































    res.status(500).json({ message: 'Failed to save submission.' });















































  }















































});















































app.delete('/api/contact/:id', verifyToken, (req, res) => {























  const db = readDB();























  const submissionId = parseInt(req.params.id, 10);























  const newSubmissions = db.formSubmissions.filter(s => s.id !== submissionId);















































  if (db.formSubmissions.length === newSubmissions.length) {























    return res.status(404).send('Submission not found');























  }















































  db.formSubmissions = newSubmissions;















































  if (writeDB(db)) {























    res.status(204).send();























  } else {























    res.status(500).json({ message: 'Failed to delete submission.' });























  }























});















































app.post('/api/track', (req, res) => {















































  const db = readDB();















































  if (!db.pageViews) db.pageViews = [];























  























  // Robust IP detection: handle x-forwarded-for header which can be a comma-separated list























  const xForwardedFor = req.headers['x-forwarded-for'];























  const ip = xForwardedFor 























    ? (Array.isArray(xForwardedFor) ? xForwardedFor[0] : xForwardedFor.split(',')[0].trim()) 























    : req.socket.remoteAddress || req.ip;















































  const newView = { id: Date.now(), path: req.body.path, timestamp: new Date().toISOString(), ip: ip };























  db.pageViews.push(newView);























  











  if (writeDB(db)) {











    res.status(201).json(newView);











  } else {











    res.status(500).json({ message: 'Failed to save page view.' });











  }











});







app.get('/api/analytics', verifyToken, (req, res) => {







  const db = readDB();







  const pageViews = db.pageViews || [];







  const totalViews = pageViews.length;















  const viewsPerDay = pageViews.reduce((acc, view) => {







    const day = view.timestamp.split('T')[0];







    acc[day] = (acc[day] || 0) + 1;







    return acc;







  }, {});















  const topPages = Object.entries(pageViews.reduce((acc, view) => {







    acc[view.path] = (acc[view.path] || 0) + 1;







    return acc;







  }, {})).sort(([, a], [, b]) => b - a).slice(0, 10);















  const uniqueVisitors = new Set(pageViews.map(view => view.ip)).size;















  // Calculate views per month for the yearly chart







  const viewsPerMonth = Array(12).fill(0);







  pageViews.forEach(view => {







    const month = new Date(view.timestamp).getMonth(); // 0 = January, 11 = December







    viewsPerMonth[month]++;







  });















  res.json({ totalViews, viewsPerDay, topPages, uniqueVisitors, viewsPerMonth });







});















app.delete('/api/analytics', verifyToken, (req, res) => {







  const db = readDB();







  db.pageViews = []; // Reset the page views







  if (writeDB(db)) {







    res.status(200).json({ message: 'Statistiky byly úspěšně resetovány.' });







  } else {







    res.status(500).json({ message: 'Nepodařilo se resetovat statistiky.' });







  }







});















app.get('/api/analytics/ips', verifyToken, (req, res) => {







    const db = readDB();







    const pageViews = db.pageViews || [];







    const viewsByIp = pageViews.reduce((acc, view) => {



        if (view.ip) acc[view.ip] = (acc[view.ip] || 0) + 1;



        return acc;



    }, {});

                    const sortedIps = Object.entries(viewsByIp).sort(([, a], [, b]) => b - a);

                    res.json(sortedIps);

                });

                

                // --- PRODUCTION STATIC SERVING ---

                // This must be AFTER all API routes.

                // Using the most robust pattern to avoid path-to-regexp errors.

                const distPath = path.join(__dirname, 'dist');

                if (fs.existsSync(distPath)) {

                    // 1. Serve static files (CSS, JS, images) from the 'dist' directory

                    app.use(express.static(distPath)); 

                

                    // 2. A final fallback middleware for any other GET request sends the React app.

                    // This avoids the app.get() router parser entirely for the catch-all.

                    app.use((req, res, next) => {

                        if (req.method === 'GET' && !res.headersSent) {

                             res.sendFile(path.join(distPath, 'index.html'));

                        } else {

                             next(); 

                        }

                    });

                }

                

                

                // --- SERVER START ---

                app.listen(port, () => {

                  initializeUser();

                  console.log(`Backend server listening at http://localhost:${port}`);

                });

